---
- name: Setup kubectl for individual nodes
  vars:
    users:
      - "root"
      - "{{ ansible_user }}"
      - "{{ user }}"
  block:
    - name: Check if kubeconfig already exists for users
      ansible.builtin.stat:
        path: ~{{ item }}/.kube/config
      loop: "{{ users }}"
      register: kubeconfig_exists

    - name: Create directory .kube for users (only if config doesn't exist)
      ansible.builtin.file:
        path: ~{{ item.item }}/.kube
        state: directory
        owner: "{{ item.item }}"
        group: "{{ item.item }}"
        mode: u=rwx,g=rx,o=
      loop: "{{ kubeconfig_exists.results }}"
      when: not item.stat.exists

    - name: Copy individual node config to user home directory (only if doesn't exist)
      ansible.builtin.copy:
        src: /etc/rancher/k3s/k3s.yaml
        dest: ~{{ item.item }}/.kube/config
        remote_src: true
        owner: "{{ item.item }}"
        group: "{{ item.item }}"
        mode: u=rw,g=,o=
      loop: "{{ kubeconfig_exists.results }}"
      when: not item.stat.exists

    - name: "Update server address in individual kubeconfig (only if newly created)"
      ansible.builtin.replace:
        path: "~{{ item.item }}/.kube/config"
        regexp: "https://127.0.0.1:6443"
        replace: "https://{{ ansible_host }}:{{ k3s_api_port | default('6443') }}"
      loop: "{{ kubeconfig_exists.results }}"
      when: not item.stat.exists

    - name: "Update context name in individual kubeconfig (only if newly created)"
      ansible.builtin.replace:
        path: "~{{ item.item }}/.kube/config"
        regexp: ": default"
        replace: ": {{ inventory_hostname }}"
      loop: "{{ kubeconfig_exists.results }}"
      when: not item.stat.exists

    - name: "Update default namespace in individual kubeconfig (only if newly created)"
      ansible.builtin.replace:
        path: "~{{ item.item }}/.kube/config"
        regexp: "namespace: default"
        replace: "namespace: chutes"
      loop: "{{ kubeconfig_exists.results }}"
      when: not item.stat.exists

    - name: "Configure default KUBECONFIG for {{ item }}"
      ansible.builtin.lineinfile:
        path: ~{{ item }}/.bashrc
        regexp: "export KUBECONFIG="
        line: "export KUBECONFIG=~{{ item }}/.kube/config # Added by k3s-ansible"
        state: present
      loop: "{{ users }}"

    - name: "Configure kubectl autocomplete for {{ item }}"
      ansible.builtin.lineinfile:
        path: ~{{ item }}/.bashrc
        regexp: "\\. <\\(kubectl completion bash\\)"
        line: ". <(kubectl completion bash)  # Added by k3s-ansible"
      loop: "{{ users }}"

- name: Build merged kubeconfig on control node
  vars:
    control_node: "{{ groups['control'][0] }}"
    control_node_users:
      - "root"
      - "{{ hostvars[control_node]['ansible_user'] }}"
      - "{{ user }}"
    temp_staging_dir: "/tmp/k3s-kubeconfig-staging"
  delegate_to: "{{ control_node }}"
  run_once: true
  block:
    - name: Create temporary staging directory on control node
      ansible.builtin.file:
        path: "{{ temp_staging_dir }}"
        state: directory
        mode: "0750"

    - name: Backup existing merged kubeconfig if it exists
      ansible.builtin.copy:
        src: "~{{ control_node_users[0] }}/.kube/config"
        dest: "{{ temp_staging_dir }}/existing_config_backup.yaml"
        remote_src: true
      ignore_errors: true

    - name: Read kubeconfigs from currently targeted hosts
      ansible.builtin.slurp:
        src: /etc/rancher/k3s/k3s.yaml
      delegate_to: "{{ item }}"
      loop: "{{ ansible_play_hosts_all | default(groups['all']) }}"
      register: kubeconfig_contents

    - name: Write collected kubeconfigs to staging directory
      ansible.builtin.copy:
        content: "{{ item.content | b64decode }}"
        dest: "{{ temp_staging_dir }}/{{ hostvars[item.item]['inventory_hostname'] }}.yaml"
        mode: "0600"
      loop: "{{ kubeconfig_contents.results }}"
      when: not item.failed | default(false)

    - name: Update server addresses in collected kubeconfigs
      ansible.builtin.replace:
        path: "{{ temp_staging_dir }}/{{ hostvars[item.item]['inventory_hostname'] }}.yaml"
        regexp: "https://127.0.0.1:6443"
        replace: "https://{{ hostvars[item.item]['ansible_host'] }}:{{ hostvars[item.item]['k3s_api_port'] | default('6443') }}"
      loop: "{{ kubeconfig_contents.results }}"
      when: not item.failed | default(false)

    - name: Update context names in collected kubeconfigs
      ansible.builtin.replace:
        path: "{{ temp_staging_dir }}/{{ hostvars[item.item]['inventory_hostname'] }}.yaml"
        regexp: ": default"
        replace: ": {{ hostvars[item.item]['inventory_hostname'] }}"
      loop: "{{ kubeconfig_contents.results }}"
      when: not item.failed | default(false)

    - name: Update default namespace in collected kubeconfigs
      ansible.builtin.replace:
        path: "{{ temp_staging_dir }}/{{ hostvars[item.item]['inventory_hostname'] }}.yaml"
        regexp: "namespace: default"
        replace: "namespace: chutes"
      loop: "{{ kubeconfig_contents.results }}"
      when: not item.failed | default(false)

    - name: Copy kubeconfig merge script to control node
      ansible.builtin.copy:
        src: merge_kubeconfigs.sh
        dest: "{{ temp_staging_dir }}/merge_kubeconfigs.sh"
        mode: "0755"

    - name: Generate fresh merged kubeconfig for each control node user
      ansible.builtin.command:
        cmd: "{{ temp_staging_dir }}/merge_kubeconfigs.sh {{ temp_staging_dir }} {{ item }}"
      loop: "{{ control_node_users }}"
      register: merge_result
      changed_when: merge_result.rc == 0

    - name: Display merge summary
      ansible.builtin.debug:
        msg: |
          Fresh kubeconfig generated on control node {{ control_node }}
          {% for result in merge_result.results %}
          {{ result.stdout }}
          {% endfor %}

    - name: Clean up temporary staging directory
      ansible.builtin.file:
        path: "{{ temp_staging_dir }}"
        state: absent

- name: Copy final kubeconfig from control node to ansible controller
  when: setup_local_kubeconfig | default(false)
  vars:
    control_node: "{{ groups['control'][0] }}"
    control_kubeconfig_source: "~{{ hostvars[control_node]['ansible_user'] }}/.kube/config"
  delegate_to: "{{ control_node }}"
  run_once: true
  block:
    - name: Ensure kubectl staging directory exists on ansible controller
      ansible.builtin.file:
        path: "{{ controller_kubectl_staging_dir | default('~/.kube') }}"
        state: directory
        mode: "0750"
      delegate_to: localhost
      become: false
      run_once: true

    - name: Fetch merged kubeconfig from control node
      ansible.builtin.fetch:
        src: "{{ control_kubeconfig_source }}"
        dest: "{{ controller_kubeconfig | default('~/.kube/config') }}"
        flat: true
      run_once: true

    - name: Verify kubectl is available on ansible controller
      ansible.builtin.command: kubectl version --client
      delegate_to: localhost
      become: false
      register: kubectl_check
      ignore_errors: true
      changed_when: false
      run_once: true

    - name: Display kubectl setup status
      ansible.builtin.debug:
        msg: |
          {% if kubectl_check.rc == 0 %}
          ✅ kubectl successfully configured on ansible controller
          Available contexts: Use 'kubectl config get-contexts' to see all cluster contexts
          {% else %}
          ⚠️  kubectl not found on ansible controller. Install kubectl to use the copied kubeconfig.
          {% endif %}
      delegate_to: localhost
      run_once: true